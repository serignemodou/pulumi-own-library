"use strict";
// Copyright 2025-2025, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
function generateSchema(providerName, version, description, components, typeDefinitions, packageReferences, namespace) {
    const result = {
        name: providerName,
        version: version,
        description: description,
        namespace: namespace,
        resources: {},
        types: {},
        language: {
            nodejs: {
                dependencies: {},
                devDependencies: {
                    typescript: "^5.0.0",
                },
                respectSchemaVersion: true,
            },
            python: {
                respectSchemaVersion: true,
            },
            csharp: {
                respectSchemaVersion: true,
            },
            java: {
                respectSchemaVersion: true,
            },
            go: {
                respectSchemaVersion: true,
            },
        },
    };
    for (const [name, component] of Object.entries(components)) {
        result.resources[`${providerName}:index:${name}`] = {
            type: "object",
            isComponent: true,
            inputProperties: component.inputs,
            requiredInputs: required(component.inputs),
            properties: component.outputs,
            required: required(component.outputs),
            description: component.description,
        };
    }
    for (const [name, type] of Object.entries(typeDefinitions)) {
        result.types[`${providerName}:index:${name}`] = {
            type: "object",
            properties: type.properties,
            required: required(type.properties),
        };
    }
    for (const [packageName, packageVersion] of Object.entries(packageReferences)) {
        result.language.nodejs.dependencies[`@pulumi/${packageName}`] = packageVersion;
        if (!result.language.python.requires) {
            result.language.python.requires = {};
        }
        if (!result.language.csharp.packageReferences) {
            result.language.csharp.packageReferences = {};
        }
        if (!result.language.java.dependencies) {
            result.language.java.dependencies = {};
        }
        result.language.python.requires[`pulumi-${packageName}`] = `==${packageVersion}`;
        const csharpPackageName = packageName
            .split("-")
            .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
            .join("");
        result.language.csharp.packageReferences[`Pulumi.${csharpPackageName}`] = packageVersion;
        result.language.java.dependencies[`com.pulumi:${packageName}`] = packageVersion;
    }
    return result;
}
exports.generateSchema = generateSchema;
function required(properties) {
    return Object.entries(properties)
        .filter(([_, def]) => !def.optional)
        .map(([propName, _]) => propName)
        .sort();
}
//# sourceMappingURL=schema.js.map